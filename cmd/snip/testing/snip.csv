uuid,timestamp,name,data
65f6930f-e970-4b6e-b10c-fca3dac21c1e,2023-06-16T13:48:55.963691-07:00,"Lorem ipsum dolor sit amet","Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc finibus felis dolor, nec vestibulum libero rhoncus at. Ut non turpis sit amet nisi malesuada commodo. Phasellus eget tellus in nunc eleifend dapibus. Curabitur accumsan ornare sem, quis consectetur risus sollicitudin sit amet. Vivamus sit amet felis laoreet, tincidunt quam sed, finibus libero. Maecenas sit amet neque velit. Aliquam ac lobortis nunc. Nam ultrices, erat ac feugiat scelerisque, nibh urna malesuada mi, at posuere nunc orci vitae ipsum. Etiam eget ante vel justo condimentum malesuada ac sit amet dui. Fusce eleifend risus ut fringilla malesuada. Nulla facilisi.

Aliquam cursus velit imperdiet ultricies laoreet. Quisque sem ante, vulputate quis elementum vitae, gravida a mauris. Vivamus vel tellus a neque porttitor porta quis nec nulla. Morbi nec sem risus. Integer ut ex vitae lacus vestibulum vulputate eget sit amet ipsum. Cras laoreet convallis imperdiet. Nunc dignissim ex a ligula auctor, mattis convallis erat semper. Ut purus tellus, luctus sollicitudin nisl a, rutrum finibus magna. Ut ac condimentum felis, at mattis ante. Donec maximus dignissim efficitur. Nulla eget odio euismod, accumsan est maximus, mollis purus. Nullam sed arcu mattis metus interdum suscipit. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Cras blandit arcu a ligula porta condimentum. Ut sit amet dapibus ex. Pellentesque ut nibh non lorem bibendum porta at ut quam.

Donec gravida, massa interdum euismod accumsan, diam nunc dictum nisl, sed molestie mauris erat a arcu. Suspendisse hendrerit lectus et justo faucibus tincidunt. Suspendisse potenti. Suspendisse quis ipsum sed libero commodo porttitor id et tellus. Fusce eu nisl dapibus elit dignissim mattis. Nam tincidunt mauris leo, at malesuada mi ultricies id. Nulla in vestibulum dui. Nulla sit amet urna pharetra, pretium ligula sit amet, interdum libero. Suspendisse ornare maximus pretium. Vivamus sodales ornare sapien, eu cursus felis consequat vel. Proin arcu nulla, feugiat in molestie at, malesuada et ante. In hac habitasse platea dictumst.

Fusce malesuada ipsum eget mi faucibus iaculis. Maecenas non tellus accumsan risus iaculis efficitur. Suspendisse auctor sem sed nulla sollicitudin lobortis. Proin dapibus consequat orci et viverra. Maecenas purus eros, malesuada et mauris nec, efficitur rhoncus ante. Maecenas urna est, dapibus eget blandit sit amet, egestas in risus. In sit amet bibendum ligula. Sed condimentum maximus tortor, et ultricies magna pretium a. Maecenas elementum, neque sit amet posuere pharetra, nibh nulla facilisis tellus, in sagittis massa sapien quis enim. Mauris aliquam nibh eget varius posuere. Suspendisse viverra augue ac urna aliquet, non consectetur libero ultricies. In hac habitasse platea dictumst. Nunc cursus porttitor mattis. Vestibulum vel congue orci. Fusce ac sodales risus, nec ultrices tortor. Mauris fringilla convallis tortor sit amet molestie.

Etiam pharetra eros sit amet felis condimentum, vel molestie eros congue. Donec erat mi, egestas in nibh a, placerat ornare leo. Donec eu fermentum nisi, a scelerisque lectus. Donec in eleifend metus, ac rutrum nibh. Aliquam porta condimentum ante vel hendrerit. In bibendum at elit at finibus. Etiam mollis mollis leo, ut porta ligula tincidunt eu. Duis vel pharetra nisl. Etiam viverra nulla eu ligula tincidunt porttitor. Donec molestie placerat ante vitae placerat. Etiam sollicitudin varius est, sit amet laoreet ante ultricies sed. Etiam aliquet, metus a aliquet suscipit, purus leo dapibus est, eget gravida ante leo quis velit.
"
990a917e-66d3-404b-9502-e8341964730b,2023-06-16T13:55:25.262371-07:00,"Tutorial: Getting started with fuzzing","https://go.dev/doc/tutorial/fuzz

Tutorial: Getting started with fuzzing

This tutorial introduces the basics of fuzzing in Go. With fuzzing, random data is run against your test in an attempt to find vulnerabilities or crash-causing inputs. Some examples of vulnerabilities that can be found by fuzzing are SQL injection, buffer overflow, denial of service and cross-site scripting attacks.

In this tutorial, youâ€™ll write a fuzz test for a simple function, run the go command, and debug and fix issues in the code.

For help with terminology throughout this tutorial, see the Go Fuzzing glossary.
"
412f7ca8-824c-4c70-80f0-4cca6371e45a,2023-06-16T14:28:28.911957-07:00,"bvinc/go-sqlite-lite README.md","[![GoDoc](https://godoc.org/github.com/bvinc/go-sqlite-lite/sqlite3?status.svg)](https://godoc.org/github.com/bvinc/go-sqlite-lite/sqlite3)
[![Build Status](https://travis-ci.com/bvinc/go-sqlite-lite.svg?branch=master)](https://travis-ci.com/bvinc/go-sqlite-lite)
[![Build status](https://ci.appveyor.com/api/projects/status/xk6fpk23wb5ppdhx?svg=true)](https://ci.appveyor.com/project/bvinc/go-sqlite-lite)
[![Coverage Status](https://coveralls.io/repos/github/bvinc/go-sqlite-lite/badge.svg?branch=master)](https://coveralls.io/github/bvinc/go-sqlite-lite?branch=master)
[![Go Report Card](https://goreportcard.com/badge/github.com/bvinc/go-sqlite-lite)](https://goreportcard.com/report/github.com/bvinc/go-sqlite-lite)

# go-sqlite-lite

go-sqlite-lite is a SQLite driver for the Go programming language.  It is designed with the following goals in mind.

* **Lightweight** - Most methods should be little more than a small wrapper around SQLite C functions.
* **Performance** - Where possible, methods should be available to allow for the highest performance possible.
* **Understandable** - You should always know what SQLite functions are being called and in what order.
* **Unsurprising** - Connections, PRAGMAs, transactions, bindings, and stepping should work out of the box exactly as you would expect with SQLite.
* **Debuggable** - When you encounter a SQLite error, the SQLite documentation should be relevant and relatable to the Go code.
* **Ergonomic** - Where it makes sense, convenient compound methods should exist to make tasks easy and to conform to Go standard interfaces.

Most database drivers include a layer to work nicely with the Go `database/sql` interface, which introduces connection pooling and behavior differences from pure SQLite.  This driver does not include a `database/sql` interface.

## Releases

* 2019-05-01 **v0.6.1** - Bug fixes, authorizer callback support
* 2019-05-01 **v0.6.0** - SQLite version 3.28.0
* 2019-02-05 **v0.5.0** - SQLite version 3.26.0
* 2018-10-30 **v0.4.2** - Better error messages from SQLite
* 2018-10-11 **v0.4.1** - Fixed an issue with new go 1.11 modules
* 2018-09-29 **v0.4.0** - SQLite version 3.25.2.  Add support for the Session extension
* 2018-09-16 **v0.3.1** - Forgot to update sqlite3.h
* 2018-09-16 **v0.3.0** - SQLite version 3.25.0
* 2018-09-14 **v0.2.0** - Proper error and NULL handling on Column* methods.  Empty blobs and empty strings are now distinct from NULL in all cases.  A nil byte slice is interpreted as NULL for binding purposes as well as Column* methods.
* 2018-09-01 **v0.1.2** - Added Column methods to Stmt, and WithTx methods to Conn
* 2018-08-25 **v0.1.1** - Fixed linking on some Linux systems
* 2018-08-21 **v0.1.0** - SQLite version 3.24.0

## Getting started

```go
import ""github.com/bvinc/go-sqlite-lite/sqlite3""
```

### Acquiring a connection
```go
conn, err := sqlite3.Open(""mydatabase.db"")
if err != nil {
	...
}
defer conn.Close()

// It's always a good idea to set a busy timeout
conn.BusyTimeout(5 * time.Second)
```

### Executing SQL
```go
err = conn.Exec(`CREATE TABLE student(name TEXT, age INTEGER)`)
if err != nil {
	...
}
// Exec can optionally bind parameters
err = conn.Exec(`INSERT INTO student VALUES (?, ?)`, ""Bob"", 18)
if err != nil {
	...
}
```

### Using Prepared Statements
```go
stmt, err := conn.Prepare(`INSERT INTO student VALUES (?, ?)`)
if err != nil {
	...
}
defer stmt.Close()

// Bind the arguments
err = stmt.Bind(""Bill"", 18)
if err != nil {
	...
}
// Step the statement
hasRow, err := stmt.Step()
if err != nil {
	...
}
// Reset the statement
err = stmt.Reset()
if err != nil {
	...
}
```

### Using Prepared Statements Conveniently
```go
stmt, err := conn.Prepare(`INSERT INTO student VALUES (?, ?)`)
if err != nil {
	...
}
defer stmt.Close()

// Exec binds arguments, steps the statement to completion, and always resets the statement
err = stmt.Exec(""John"", 19)
if err != nil {
	...
}
```

### Using Queries Conveniently
```go
// Prepare can prepare a statement and optionally also bind arguments
stmt, err := conn.Prepare(`SELECT name, age FROM student WHERE age = ?`, 18)
if err != nil {
	...
}
defer stmt.Close()

for {
	hasRow, err := stmt.Step()
	if err != nil {
		...
	}
	if !hasRow {
		// The query is finished
		break
	}

	// Use Scan to access column data from a row
	var name string
	var age int
	err = stmt.Scan(&name, &age)
	if err != nil {
		...
	}
	fmt.Println(""name:"", name, ""age:"", age)
}
// Remember to Reset the statement if you would like to Bind new arguments and reuse the prepared statement
```

### Getting columns that might be NULL
Scan can be convenient to use, but it doesn't handle NULL values.  To get full control of column values, there are column methods for each type.
```go
name, ok, err := stmt.ColumnText(0)
if err != nil {
	// Either the column index was out of range, or SQLite failed to allocate memory
	...
}
if !ok {
	// The column was NULL
}

age, ok, err := stmt.ColumnInt(1)
if err != nil {
	// Can only fail if the column index is out of range
	...
}
if !ok {
	// The column was NULL
}
```

`ColumnBlob` returns a nil slice in the case of NULL.
```go
blob, err := stmt.ColumnBlob(i)
if err != nil {
	// Either the column index was out of range, or SQLite failed to allocate memory
	...
}
if blob == nil {
	// The column was NULL
}
```



### Using Transactions
```go
// Equivalent to conn.Exec(""BEGIN"")
err := conn.Begin()
if err != nil {
	...
}

// Do some work
...

// Equivalent to conn.Exec(""COMMIT"")
err = conn.Commit()
if err != nil {
	...
}
```

### Using Transactions Conveniently

With error handling in Go, it can be pretty inconvenient to ensure that a transaction is rolled back in the case of an error.  The `WithTx` method is provided, which accepts a function of work to do inside of a transaction.  `WithTx` will begin the transaction and call the function.  If the function returns an error, the transaction will be rolled back.  If the function succeeds, the transaction will be committed.  `WithTx` can be a little awkward to use, but it's necessary.  For example:

```go
err := conn.WithTx(func() error {
	return insertStudents(conn)
})
if err != nil {
	...
}

func insertStudents(conn *sqlite3.Conn) error {
	...
}
```

## Advanced Features
* Binding parameters to statements using SQLite named parameters.
* SQLite Blob Incremental IO API.
* SQLite Online Backup API.
* SQLite Session extension.
* Supports setting a custom busy handler
* Supports callback hooks on commit, rollback, and update.
* Supports setting compile-Time authorization callbacks.
* If shared cache mode is enabled and one statement receives a `SQLITE_LOCKED` error, the SQLite [unlock_notify](https://sqlite.org/unlock_notify.html) extension is used to transparently block and try again when the conflicting statement finishes.
* Compiled with SQLite support for JSON1, RTREE, FTS5, GEOPOLY, STAT4, and SOUNDEX.
* Compiled with SQLite support for OFFSET/LIMIT on UPDATE and DELETE statements.
* RawString and RawBytes can be used to reduce copying between Go and SQLite.  Please use with caution.

## Credit
This project began as a fork of https://github.com/mxk/go-sqlite/

## FAQ

* **Why is there no `database/sql` interface?**

If a `database/sql` interface is required, please use https://github.com/mattn/go-sqlite3 .  In my experience, using a `database/sql` interface with SQLite is painful.  Connection pooling causes unnecessary overhead and weirdness.  Transactions using `Exec(""BEGIN"")` don't work as expected.  Your connection does not correspond to SQLite's concept of a connection.  PRAGMA commands do not work as expected.  When you hit SQLite errors, such as locking or busy errors, it's difficult to discover why since you don't know which connection received which SQL and in what order.

* **What are the differences between this driver and the mxk/go-sqlite driver?**

This driver was forked from `mxk/go-sqlite-driver`.  It hadn't been maintained in years and used an ancient version of SQLite.  A large number of features were removed, reworked, and renamed.  A lot of smartness and state was removed.  It is now much easier to upgrade to newer versions of SQLite since the `codec` feature was removed.  The behavior of methods now lines up closely with the behavior of SQLite's C API.

* **What are the differences between this driver and the crawshaw/sqlite driver?**

The crawshaw driver is pretty well thought out and solves a lot of the same problems as this
driver.  There are a few places where our philosophies differ.  The crawshaw driver defaults (when flags of 0 are given) to SQLite shared cache mode and WAL mode.  The default WAL synchronous mode is changed.  Prepared statements are transparently cached.  Connection pools are provided.  I would be opposed to making most of these changes to this driver.  I would like this driver to provide a default, light, and unsurprising SQLite experience.

* **Are finalizers provided to automatically close connections and statements?**

No finalizers are used in this driver.  You are responsible for closing connections and statements.  While I mostly agree with finalizers for cleaning up most accidental resource leaks, in this case, finalizers may fix errors such as locking errors while debugging only to find that the code works unreliably in production.  Removing finalizers makes the behavior consistent.

* **Is it thread safe?**

go-sqlite-lite is as thread safe as SQLite.  SQLite with this driver is compiled with `-DSQLITE_THREADSAFE=2` which is **Multi-thread** mode.  In this mode, SQLite can be safely used by multiple threads provided that no single database connection is used simultaneously in two or more threads.  This applies to goroutines.  A single database connection should not be used simultaneously between two goroutines.

It is safe to use separate connection instances concurrently, even if they are accessing the same database file. For example:
```go
// ERROR (without any extra synchronization)
c, _ := sqlite3.Open(""sqlite.db"")
go use(c)
go use(c)
```
```go
// OK
c1, _ := sqlite3.Open(""sqlite.db"")
c2, _ := sqlite3.Open(""sqlite.db"")
go use(c1)
go use(c2)
```

Consult the SQLite documentation for more information.

https://www.sqlite.org/threadsafe.html

* **How do I pool connections for handling HTTP requests?**

Opening new connections is cheap and connection pooling is generally unnecessary for SQLite.  I would recommend that you open a new connection for each request that you're handling.  This ensures that each request is handled separately and the normal rules of SQLite database/table locking apply.

If you've decided that pooling connections provides you with an advantage, it would be outside the scope of this package and something that you would need to implement and ensure works as needed.

## License
This project is licensed under the BSD license.
"
